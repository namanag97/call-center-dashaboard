<context>

# Overview
This document outlines the Product Requirements for building and testing the User Interface (UI) of the Call Analyser. The Call Analyser is a SaaS platform designed to empower Service Call Center Managers and B2B Account Managers by providing automated transcription, AI-driven analysis, and insightful reporting from call recordings. This PRD focuses *exclusively* on the frontend application â€“ the user-facing web interface. It details the requirements for creating a modern, performant, responsive, accessible, and highly testable UI using React, Vite, TypeScript, and Storybook. The core problem this UI solves is presenting complex call data, analysis results, and user actions (upload, configuration, review) in an intuitive and efficient manner, ultimately enabling users to gain value from the underlying backend services.

# Core Features (UI Perspective)
*   **Dashboard Display:**
    *   *What it does:* Presents key performance indicators and system status metrics visually upon login.
    *   *Why it's important:* Provides users with an immediate, high-level understanding of call volume, processing status, and key analysis trends without needing to delve into detailed reports.
    *   *How it works:* Utilizes `StatisticCard` and `ChartComponent` components to display data fetched (and managed by state) from relevant backend endpoints.
*   **Call Listing & Interaction:**
    *   *What it does:* Displays a comprehensive list of ingested calls in a structured `DataTable` with support for sorting, searching, and advanced filtering. Allows users to select calls for bulk actions.
    *   *Why it's important:* Enables users to efficiently navigate, find, and manage large volumes of call records based on various criteria relevant to their workflow.
    *   *How it works:* Uses a `DataTable` component populated with data managed via a state store, integrates `FilterControls`, `SearchBar`, and `Pagination`, and includes interactive elements like checkboxes for selection, triggering context-specific action buttons.
*   **Call Detail Presentation:**
    *   *What it does:* Offers an integrated view combining audio playback (`AudioPlayer`), synchronized transcript viewing (`TranscriptViewer`), display of AI analysis (`AnalysisResultsPanel`), and a section for Quality Assurance (`QAPanel`).
    *   *Why it's important:* Provides the core interface for detailed call review, verification of AI results, and agent performance evaluation, centralizing all relevant information for a single call.
    *   *How it works:* Orchestrates multiple specialized components on one screen, managing state for audio playback position, transcript highlighting, and QA input, fetching detailed data for the specific call ID.
*   **Call Ingestion Interface:**
    *   *What it does:* Provides the UI (`CallUploader`) for users to select local audio files, associate necessary metadata (`MetadataForm`), initiate the upload process, and receive real-time visual feedback on progress and completion status (`FileList`, `FileItem`).
    *   *Why it's important:* Offers a user-friendly mechanism for getting call recordings into the system, which is the prerequisite for all analysis.
    *   *How it works:* Utilizes file input/drag-and-drop libraries, manages frontend state for selected files and metadata, communicates with the backend ingestion API, and updates the UI based on progress events and API responses.
*   **Settings Configuration Interface:**
    *   *What it does:* Presents forms and lists within a structured `SettingsLayout` allowing administrators to manage configurations like API keys for Transcription/AI providers and define parameters like analysis categories.
    *   *Why it's important:* Enables customization and integration of the Call Analyser with the user's specific tools and business logic.
    *   *How it works:* Uses standard form components (`Input`, `Button`, `Dropdown`), potentially within `Modal` dialogs or tabbed views, to interact with backend settings endpoints. Displays current configurations in lists (`ProviderList`) or tables.
*   **User Authentication Interface:**
    *   *What it does:* Provides standard `LoginForm` and logout functionality, managing the user's session state within the application.
    *   *Why it's important:* Secures access to the application and user data.
    *   *How it works:* A dedicated login page/route renders the `LoginForm`. Upon successful authentication (verified via API), user context and tokens are stored (e.g., in Zustand state, potentially persisted), enabling access to protected routes and displaying user information (`UserMenu`).

# User Experience
*   **User Personas:**
    *   *Sarah (Call Center Manager):* Needs efficiency, clear data visualization (trends, agent performance metrics via lists/details), easy QA workflow. Values reliable status feedback.
    *   *Priya (B2B Account Manager):* Needs quick access to client call history (filtering/searching), integrated view of context (detail screen), ability to add notes. Values intuitive navigation.
    *   *Admin/Ops User:* Needs clear, straightforward forms for configuration, visibility into integration status. Values simple management interfaces.
*   **Key User Flows (UI Focus):**
    1.  *Review Call:* Login -> (Dashboard) -> Call List -> Filter/Search Calls -> Select Call -> View Call Detail -> Play Audio & Read Transcript -> Review AI Analysis -> [Optional: Add QA Note/Override Category -> Save QA] -> Navigate Back/Next.
    2.  *Upload Calls:* Login -> Upload Calls Page -> Select/Drag Files -> Fill Metadata Form -> Start Upload -> Monitor `FileItem` Progress -> View Summary Status.
    3.  *Configure Settings:* Login -> Settings Page -> Select Provider Tab -> View `ProviderList` -> Add/Edit Provider via `ProviderForm` -> Save -> View Updated List.
    4.  *Login/Logout:* Navigate to App -> View Login Page -> Enter Credentials -> Submit `LoginForm` -> View Dashboard // Click `UserMenu` -> Logout -> View Login Page.
*   **UI/UX Considerations:**
    *   *Navigation:* Predictable and consistent via persistent `Sidebar` and informative `TopHeader`/`PageHeader`.
    *   *Responsiveness:* Desktop-first design with graceful adaptation ("wrapping") to standard tablet viewports ensured by Tailwind modifiers and component logic where needed.
    *   *Feedback:* Immediate visual confirmation for actions (clicks, saves), clear loading indicators (`Spinner`, `ProgressBar`), distinct success/error/info `Alert` messages, inline form validation.
    *   *Accessibility:* Target WCAG 2.1 AA compliance (keyboard navigation, semantic HTML, sufficient color contrast, screen reader compatibility tested via Storybook addon and E2E checks).
    *   *Performance:* Prioritize fast initial load (via Vite build optimizations, code splitting) and snappy UI interactions (efficient state management, optimized component rendering).
    *   *Consistency:* Uniform look-and-feel achieved through reusable primitive components, defined layout structures, and consistent application of Tailwind utilities/design tokens.

</context>
<PRD>

# Technical Architecture (UI Build & Test Focus)

*   **System Components:**
    *   **Framework/Library:** React v18+ with TypeScript.
    *   **Build Tool:** Vite v4.x+ (configured for TS, React Fast Refresh).
    *   **Runtime (Development/Build):** Bun v1.x+ (for running Vite dev server, build scripts, tests).
    *   **Styling:** Tailwind CSS v3.x+ (configured with project design tokens).
    *   **State Management:** Zustand v4.x+ (using slice pattern, devtools middleware).
    *   **Routing:** `react-router-dom` v6+ (client-side routing, lazy loading).
    *   **API Client:** Standard `fetch` or `ky`.
    *   **API Mocking:** `msw` (Mock Service Worker) v2+ (REQUIRED for dev, storybook, testing).
    *   **Component Development/Testing:** Storybook v7.x+ (`@storybook/react-vite`).
        *   **Addons:** `@storybook/addon-essentials`, `@storybook/addon-a11y`, `@storybook/addon-interactions`, integration with MSW loader (`msw-storybook-addon` or custom decorator).
        *   **Global Contexts:** Storybook decorators configured in `./storybook/preview.ts` MUST provide mock implementations/wrappers for Router, Zustand Stores, Theme, and Auth context required by components.
    *   **Unit/Integration Testing:** `bun:test` runner with `@testing-library/react`. Tests run against components connected to mocked stores and interacting with MSW handlers.
    *   **E2E Testing:** Playwright. Tests run against the assembled application using mocked APIs (MSW).
    *   **Visual Regression Testing:** Chromatic (integrated with Storybook deployment).
*   **Data Models (Frontend State):** Zustand stores will manage UI state, including: user session/profile, list filters, selected items, upload progress/status per file, current call detail data, settings form data, loading/error states for API interactions. Types will mirror backend API responses where applicable, sourced from `packages/shared-types`.
*   **APIs and Integrations (UI Perspective):** The UI integrates with backend REST APIs for: Authentication (Login/Logout), Call Data (List fetching, Detail fetching), Metadata (Configuration fetching/updating), Analysis triggering, Upload initiation. All API interactions MUST be mockable via MSW.
*   **Infrastructure Requirements (UI Build/Deploy):**
    *   Node.js/Bun environment for development and building.
    *   CI/CD pipeline (e.g., GitHub Actions) for: linting, type checking, running tests (unit, integration, optionally E2E), building the static frontend assets (via `vite build`), deploying Storybook (to Chromatic/other), deploying frontend assets (to CDN/hosting).
    *   Static file hosting (e.g., Vercel, Netlify, S3+CloudFront) for the built frontend application.

# Development Roadmap (UI Build & Test Focus)

*   **Phase 0: Foundation & Tooling Setup**
    *   **Scope:** Initialize monorepo (Bun workspaces), Vite/React/TS frontend app, Base Tailwind config, Storybook v7+ integration, `bun:test` & RTL setup, Playwright setup, MSW setup, Linter/Formatter config, Base CI pipeline for checks and Storybook deployment (Chromatic). Setup `packages/shared-types`.
    *   **Components Built:** None (Placeholder/Example component in Storybook only).
    *   **Goal:** Stable development environment, runnable Storybook, basic CI checks passing.
*   **Phase 1: Primitives, Layout & Core Storybook Config**
    *   **Scope:** Define core design tokens in Tailwind. Implement and test core primitive components within Storybook, ensuring comprehensive story coverage for variants and states. Implement main layout components. Configure Storybook decorators for global providers (Router, Mock Stores, Theme). Define base MSW handlers needed for layout/primitives (e.g., mock user session).
    *   **Components Built (with Stories):** `Button`, `Input`, `Label`, `Text`, `Icon`, `Alert`, `Spinner`, `Modal`, `Dropdown`, `Checkbox`, `Tooltip`, `Badge`, `ProgressBar`, `AppLayout`, `Sidebar`, `TopHeader`, `NavLink`, `UserMenu`, `PageHeader`, `LoginPageLayout`.
    *   **Goal:** A documented, visually consistent set of UI building blocks and the main application shell testable in Storybook.
*   **Phase 2: Feature Component Implementation (Storybook Isolation)**
    *   **Scope:** Build feature-specific components using primitives from Phase 1. Develop *within Storybook first*, mocking all necessary data and state via Storybook args/loaders and MSW handlers specific to the stories. Define necessary types in `packages/shared-types`. Implement component logic and internal state where needed. Write interaction tests within stories.
    *   **Components Built (with Stories):** `LoginForm`, `DataTable`, `Pagination`, `FilterControls`, `SearchBar`, `CallUploader`, `FileList`, `FileItem`, `MetadataForm`, `AudioPlayer`, `TranscriptViewer`, `AnalysisResultsPanel`, `QAPanel`, `SettingsLayout`, `ProviderList`, `ProviderForm`, `CategoryListEditor`, `ConcurrencyControl`, `StatisticCard`, `ChartComponent`.
    *   **Goal:** All major functional UI pieces are developed, visually tested, documented, and interaction-tested in isolation via Storybook.
*   **Phase 3: State Management, Page Assembly & Mocked Integration**
    *   **Scope:** Implement Zustand stores (slices) for managing application state (auth, uploads, call list/detail, settings). Connect Phase 2 components to these stores. Assemble components into full page views/routes (`LoginPage`, `DashboardPage`, `CallListPage`, `CallDetailPage`, `UploadPage`, `SettingsPage`). Implement client-side routing (`react-router-dom`) with lazy loading. Ensure MSW handlers provide realistic data flow for navigating between assembled pages.
    *   **Components Built:** Page-level components orchestrating feature components.
    *   **Goal:** A navigable, stateful UI prototype running entirely against mocked APIs, demonstrating core user flows.
*   **Phase 4: E2E Testing, Polishing & Optimization**
    *   **Scope:** Write Playwright E2E tests for critical user flows identified in UX section (covering navigation, interaction, responsiveness, basic accessibility checks). Refine responsive behavior ("wrapping") based on testing. Polish animations/transitions. Perform bundle analysis and optimize where needed (code splitting verification, lazy loading). Conduct final accessibility audits (manual checks + automated tools). Stabilize visual regression baselines in Chromatic.
    *   **Components Built:** No new components, focus is on integration testing and refinement.
    *   **Goal:** A robust, performant, accessible, and well-tested UI ready for integration with live backend APIs.

# Logical Dependency Chain (UI Build & Test Focus)

1.  **Foundation:** Setup Project, Tooling (Vite, Bun, TS, Storybook, Testing Libs, MSW).
2.  **Styling Base:** Configure Tailwind theme/tokens.
3.  **Shared Types:** Define initial structures in `packages/shared-types`.
4.  **Storybook Config:** Setup global decorators (Router, Mock Stores, MSW).
5.  **Primitives (Storybook):** Build & test base components (`Button`, `Input`, etc.).
6.  **Layouts (Storybook):** Build & test app shell (`AppLayout`, `Sidebar`, etc.).
7.  **Feature Components (Storybook):** Build & test isolated feature UIs (`CallUploader`, `DataTable`, etc.) using primitives, mocks, shared types.
8.  **State Stores:** Implement Zustand stores based on component data needs.
9.  **Pages & Routing:** Assemble components into pages, connect stores, implement router, lazy loading.
10. **MSW Integration:** Ensure comprehensive MSW handlers support assembled page flows.
11. **E2E Tests:** Write tests covering assembled flows against MSW.
12. **Refinement:** Address E2E/visual/performance/accessibility test feedback.

# Risks and Mitigations (UI Build & Test Focus)

*   **Risk:** Friction between `Bun Test` and React Testing Library/Mocking.
    *   **Mitigation:** Allocate buffer time in Phase 1 for potential migration to Vitest if significant, unresolvable issues arise with `Bun Test`. Ensure test patterns are runner-agnostic where possible.
*   **Risk:** Complex or buggy state management.
    *   **Mitigation:** Enforce Zustand slice pattern, use devtools for debugging, conduct focused code reviews on state logic, write unit tests for store actions/selectors.
*   **Risk:** API mocks diverging from actual backend implementation.
    *   **Mitigation:** STRICT use of `packages/shared-types` synced with backend. Regular (manual or semi-automated) validation of mocks against live dev backend. Implement contract testing post-MVP. Leverage MSW's unhandled request warnings.
*   **Risk:** Storybook setup for global contexts is complex or incorrect.
    *   **Mitigation:** Prioritize setting up and validating Storybook decorators early in Phase 1. Document the setup clearly. Provide examples for component developers.
*   **Risk:** TypeScript type inconsistencies between frontend/backend or within frontend.
    *   **Mitigation:** Mandate `strict: true` in `tsconfig.json`. Centralize shared types in `packages/shared-types`. Use type inference and utility types effectively. Regular type checking via CI.
*   **Risk:** Responsive design implementation is inconsistent or buggy.
    *   **Mitigation:** Adhere to defined strategy (Tailwind modifiers + JS hooks for complexity). Test thoroughly across target breakpoints using Storybook viewport addon and Playwright E2E tests. Code reviews check responsive implementation.
*   **Risk:** Overly complex or unmaintainable Tailwind class compositions.
    *   **Mitigation:** Follow CSS organization guidelines (prefer composition via components). Code reviews specifically look for overly complex/repetitive class strings. Use Tailwind plugins judiciously.
*   **Risk:** Poor frontend performance (large bundles, slow interactions).
    *   **Mitigation:** Leverage Vite's optimizations. Implement route-based code splitting and lazy loading from the start (Phase 3/4). Use bundle analyzer periodically. Profile component rendering if needed. Optimize state selections in components.
*   **Risk:** Difficulty tracking component evolution visually.
    *   **Mitigation:** Use Chromatic for visual diffing and history tracking integrated with Git history. Storybook always reflects the *current* code state. Application versioning handles release states.
*   **Risk:** Inconsistent or inadequate error handling presentation.
    *   **Mitigation:** Implement defined architecture (component vs. global errors, Error Boundaries). Use standardized `Alert` components. Include error states in Storybook stories and E2E tests.

# Appendix
*   **Component Implementation Details:** [Link to potential TSD or component-level documentation]
*   **Deployed Storybook:** [URL Placeholder - e.g., Chromatic link]
*   **Figma Designs:** [Link Placeholder]
*   **API Contract Documentation (Backend):** [Link Placeholder]
*   **MSW Mock Definitions:** Reside in `apps/frontend/src/mocks/`